import numpy as np

#a function to generate a random hypervector of length D filled with an equal amount of 1 and -1.
def genRandomHV(D):
	if D%2 == 1:
		print("Dimension is odd!")
	else:
		randomIndex = np.random.permutation(D) 							#create a D array with random permutations
		entries = range(D)
		randomHV = np.zeros((len(entries),))							#preallocate array, from chrisschell.de
		half = D/2
		randomHV[np.where(randomIndex < half)] = 1; 					#find permutation array < half, those index set to 1
		randomHV[np.where(randomIndex >= half)] = -1;					#^^^^^ same, but set to -1
		#print(np.mean(randomHV)) 										for testing the random hypervector function
		return randomHV

# this function takes in an item memory (in MATLAB, essentially a 2D array
# designed for easy lookups and data matching, see MATLAB documentation, a key
# (which is a values name to search for, in this case each trigram has a corresponding
# HV if the key (or trigram) isn't present, it is created with genRandomHV
# for this implementation, a dictionary will be used

def lookupItemMemory(itemMemory, key, D):
	if key in itemMemory:
		randomHV = itemMemory[key]										#found the key!
	else:
		itemMemory[key] = genRandomHV(D)
		randomHV = itemMemory[key]
	return itemMemory, randomHV
		
		

def computeSumHV (buff, itemMemory, N, D):
	#init
	block = np.zeros(N,D)
	sumHV = np.zeros(1, D)
	
	for numItems in range(0, np.size(buff)):
		key = buff[numItems]
		
		block = np.roll(block, 1, [0,1])
		itemMemory, block(1,:) = lookupItemMemory(itemMemory, key, D)
		
		if numItems >= N:
			nGrams = block(1, :)
			for i in range(1,N):
				nGrams = nGrams * block(i, :)
			sumHV = sumHV + nGrams
	return itemMemory, sumHV


def binarizeHV (v):														#v is a hyper vector
	threshold = 0
	for i in v:
		if v[i] < threshold:
			v[i] = 1
		else:
			v[i] = -1



if __name__ == '__main__':
    D = input("Enter dimensions: ")
    dict = {
		
    }
